# 类加载

## 类加载到虚拟机内存到卸载的整个生命周期
* 整个生命周期包括:加载
(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化
(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个
部分统称为连接(Linking)

## 什么时候开始“初始化”
* 有且只有5种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要
在此之前开始):

* **1)遇到new、getstatic、putstatic或invokestatic这4条字节码指令时,如果类没有进行过初
始化,则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是:使用new关键字
实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常
量池的静态字段除外)的时候,以及调用一个类的静态方法的时候。**

* **2)使用java.lang.reflect包的方法对类进行反射调用的时候,如果类没有进行过初始化,
则需要先触发其初始化。**

* **3)当初始化一个类的时候,如果发现其父类还没有进行过初始化,则需要先触发其父
类的初始化。**

* **4)当虚拟机启动时,用户需要指定一个要执行的主类(包含main()方法的那个
类),虚拟机会先初始化这个主类。**

* **5)当使用JDK
1.7的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄,并且这个方法句柄
所对应的类没有进行过初始化,则需要先触发其初始化。**

* 这5种场景中的行为称为对一个类进行主动引用。除此之外,所有引用类的方式都
不会触发初始化,称为被动引用。

## 接口与类

* 接口与类真正有所区别的是前面讲述的5种“有
且仅有”需要开始初始化场景中的第3种:当一个类在初始化时,要求其父类全部都已经初始
化过了,但是一个接口在初始化时,并不要求其父接口全部都完成了初始化,只有在真正使
用到父接口的时候(如引用接口中定义的常量)才会初始化。

## 类加载的过程

### 加载阶段

在加载阶段,虚拟机需要完成以下3件事情:

* 1)通过一个类的全限定名来获取定义此类的二进制字节流。
* 2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
* 3)在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据
的访问入口。

### 连接阶段
* 加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的,
加载阶段尚未完成,连接阶段可能已经开始,但这些夹在加载阶段之中进行的动作,仍然属
于连接阶段的内容,这两个阶段的开始时间仍然保持着固定的先后顺序。

#### 验证
* 验证是连接阶段的第一步,这一阶段的目的是为了确保Class文件的字节流中包含的信息
符合当前虚拟机的要求,并且不会危害虚拟机自身的安全。

* 从整体上看,验证阶段大致上会完成下面4个阶段的检验动作:文件格式验证、
元数据验证、字节码验证、符号引用验证。

##### 文件格式验证
* 是否以魔数0xCAFEBABE开头。
* 主、次版本号是否在当前虚拟机处理范围之内。
* 常量池的常量中是否有不被支持的常量类型(检查常量tag标志)。
* 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
* CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。
* Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。

##### 元数据验证
* 这个类是否有父类(除了java.lang.Object之外,所有的类都应当有父类)。
* 这个类的父类是否继承了不允许被继承的类(被final修饰的类)。
* 如果这个类不是抽象类,是否实现了其父类或接口之中要求实现的所有方法。
* 类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的final字段,或者出现不符合
规则的方法重载,例如方法参数都一致,但返回值类型却不同等)。

##### 字节码验证
* ...

##### 符号引用验证
* ...

#### 准备
* 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些变量所使用的内存
都将在方法区中进行分配。

* **这时候进行内存分配的仅包括类变量(被static修饰的变量),而不包括实例变量,实例变量将
会在对象实例化时随着对象一起分配在Java堆中。其次,这里所说的初始值“通常情况”下是
数据类型的零值**

比如

```java
public static int value=123;
```

**变量value在准备阶段过后的初始值为0而不是123,因为这时候尚未开始执行任何Java
方法,而把value赋值为123的putstatic指令是程序被编译后,存放于类构造器<clinit>()方
法之中,所以把value赋值为123的动作将在初始化阶段才会执行。**

#### 解析
* 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

* **符号引用(Symbolic References):符号引用以一组符号来描述所引用的目标,符号可
以是任何形式的字面量,只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的
内存布局无关,引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各
不相同,但是它们能接受的符号引用必须都是一致的,因为符号引用的字面量形式明确定义
在Java虚拟机规范的Class文件格式中。**

* **直接引用(Direct References):直接引用可以是直接指向目标的指针、相对偏移量或是
一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的,同一个符号引
用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用,那引用的目
标必定已经在内存中存在。**
