# 简介
* 对于Java程序员来说,在虚拟机自动内存管理机制的帮助下,不再需要为每一个new操
作去写配对的delete/free代码,但是我们依旧需要了解虚拟机是怎样使用内存的

# 运行时数据区域
* 运行时数据区域包括，方法区，堆，虚拟机栈，本地方法栈，程序计数器

## 程序计数器
* 程序计数器(Program Counter Register)是一块较小的内存空间,它可以看作是当前线
程所执行的字节码的行号指示器。它为“线程私有”的内存

* 如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指
令的地址;如果正在执行的是Native方法,这个计数器值则为空(Undefined)。此内存区域
是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

## Java虚拟机栈
* 虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时
都会创建一个栈帧(Stack Frame )用于存储局部变量表、操作数栈、动态链接、方法出口
等信息。每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出
栈的过程。

* 与程序计数器相同，一样为线程私有。

* 对这个区域规定了两种异常状况:如果线程请求的栈深度大于虚拟机所允许的深度,将抛出
StackOverflowError异常;如果虚拟机栈可以动态扩展(当前大部
分的Java虚拟机都可动态扩展,只不过Java虚拟机规范中也允许固定长度的虚拟机栈),如
果扩展时无法申请到足够的内存,就会抛出OutOfMemoryError异常。

## 本地方法栈
* 本地方法栈(Native Method Stack)与虚拟机栈之间
的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚
拟机使用到的Native方法服务。

* 与虚拟机栈一样,本地方法
栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

## Java堆
* Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建。

* 此内存区域的唯一目的就
是存放对象实例,几乎所有的对象实例都在这里分配内存。

* Java堆是垃圾收集器管理的主要区域,被称做“GC堆”

* 从内存回收的角度来看,由于现在收集器基
本都采用分代收集算法,所以Java堆中还可以细分为:新生代和老年代;再细致一点的有
Eden空间、From Survivor空间、To Survivor空间等。

* 从内存分配的角度来看,线程共享的
Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)。

* Java堆可以处于物理上不连续的内存空间中,只要逻辑上
是连续的即可

* 如
果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异
常。

## 方法区
* 方法区(Method Area)与Java堆一样,是各个线程共享的内存区域,它用于存储已被虚
拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

* 相对而言,垃圾收集行为在这个
区域是比较少出现的

### 运行时常量池
* 运行时常量池(Runtime Constant Pool)是方法区的一部分

* Class文件中除了有类的版
本、字段、方法、接口等描述信息外,还有一项信息是常量池(Constant Pool Table),用于
存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常
量池中存放。

## 直接内存
* 直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规
范中定义的内存区域。
