# 垃圾回收机制

## 引用计数算法
* 给对象中添加一个引用计数器,每当有
一个地方引用它时,计数器值就加1;当引用失效时,计数器值就减1;任何时刻计数器为0
的对象就是不可能再被使用的。**但是它很难解决对象
之间相互循环引用的问题**

## 可达性分析算法
* 这个算法的基本思
路就是通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所
走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连
(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。

### 可作为GC Roots的对象

* 虚拟机栈(栈帧中的本地变量表)中引用的对象

* 方法区中类静态属性引用的对象

* 方法区中常量引用的对象

* 本地方法栈中JNI(即一般说的Native方法)引用的对象。

## 回收方法区

* 永久代的垃圾收集主要回收两部分内容:废弃常量和无用的类。

### 类需要同时满足下面3个条件才能算是“无用的类”:

* 该类所有的实例都已经被回收,也就是Java堆中不存在该类的任何实例。

* 加载该类的ClassLoader已经被回收。

* 该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该
类的方法。


**虚拟机可以对满足上述3个条件的无用类进行回收,这里说的仅仅是“可以”,而并不是
和对象一样,不使用了就必然会回收。**

**在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁
自定义ClassLoader的场景都需要虚拟机具备类卸载的功能,以保证永久代不会溢出。**

## 垃圾收集算法

### 标记-清除算法

* 算法分
为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象,在标记完成后统一回收所有
被标记的对象

* 主要不足有两个:一个是效率问题,标记和清除两个过程的效率都不高;另一个是
空间问题,标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致以后在程
序运行过程中需要分配较大对象时,无法找到足够的连续内存而不得不提前触发另一次垃圾
收集动作。

## 复制算法
* 它将可用内存按容
量划分为大小相等的两块,每次只使用其中的一块。当这一块的内存用完了,就将还存活着
的对象复制到另外一块上面,然后再把已使用过的内存空间一次清理掉。这样使得每次都是
对整个半区进行内存回收,内存分配时也就不用考虑内存碎片等复杂情况,只要移动堆顶指
针,按顺序分配内存即可,实现简单,运行高效。

* 现在的商业虚拟机都采用这种收集算法来回收新生代

* 将内存
分为一块较大的Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor 。
当回收时,将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上,最
后清理掉Eden和刚才用过的Survivor空间。

## 标记-整理算法
* 标记过程
仍然与“标记-清除”算法一样,但后续步骤不是直接对可回收对象进行清理,而是让所有存
活的对象都向一端移动,然后直接清理掉端边界以外的内存

## 分代收集算法

* 根据对象存活周期的不同将内存划分为几块。一般是把Java堆
分为新生代和老年代,这样就可以根据各个年代的特点采用最适当的收集算法。
